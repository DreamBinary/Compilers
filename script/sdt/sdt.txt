0 : PROGRAM_ -> PROGRAM ${

}$
1 : PROGRAM -> STATEMENTLIST ${

}$
2 : INDEX -> INT ${
stack[top].value = int(stack[top].value);
}$
3 : INDEX -> VARIABLE ${

}$
4 : TYPE -> INTEGER ${
type = 'integer';
stack[top].width = 4;
}$
5 : TYPE -> DOUBLE ${
type = 'double';
stack[top].width = 8;
}$
6 : TYPE -> EPSILON ${
type = None;
}$
7 : VARIABLE -> TYPE IDENTIFIER ${
if type is not None:
    table[stack[top].value] = (type, stack[top-1].width);
stack[top-1].value = stack[top].value;
# stack[top-1].width = stack[top-1].width;
top -= 1;
}$
8 : VARIABLE -> VARIABLE [ INDEX ] ${
if type is None:
    if stack[top-3].value not in table:
        error(f"Variable {stack[top-3].value} not declared.");
    else:
        type = table[stack[top-3].value][0];
        stack[top-3].width = 4 if type.startswith('integer') else 8;
    tmp = temp();
    gen('*', stack[top-3].width, stack[top-1].value, tmp);
    tmp2 = temp();
    gen('', f"{stack[top-3].value}[{tmp}]", None, tmp2);
    stack[top-3].value = tmp2;
else:
    stack[top-3].width = stack[top-3].width * stack[top-1].value;
    table[stack[top-3].value] = (f"{type}[]", stack[top-3].width);
    stack[top-3].value = f"{stack[top-3].value}[{stack[top-1].value}]";
top -= 3;
}$
9 : VARIABLE -> VARIABLE [ INDEX ] [ INDEX ] ${

}$
10 : STATEMENTLIST -> STATEMENT ${

}$
11 : STATEMENTLIST -> STATEMENTLIST STATEMENT ${
backpatch(stack[top-1].nextlist, nextinstr - 1); # nextinstr - 1 is the last instruction of the previous statement
stack[top-1].nextlist = merge(stack[top-1].nextlist, stack[top].nextlist);
stack[top-1].value = stack[top].value;
top -= 1;
}$
12 : STATEMENTLIST -> EPSILON ${

}$
13 : STATEMENT -> STATEMENTNO ${

}$
14 : STATEMENT -> STATEMENTNO ; ${
top -= 1;
}$
15 : STATEMENTNO -> VARIABLE ${

}$
16 : STATEMENTNO -> VARIABLE = ASSIGN ${
if stack[top-2].value not in table:
    error(f"Variable {stack[top-2].value} not declared.");
else:
    gen('=', stack[top-2].value, stack[top].value);
top -= 2;
}$
17 : STATEMENTNO -> EXPRESSIONLIST ${

}$
18 : STATEMENTNO -> IFSTMT ${

}$
19 : STATEMENTNO -> REPEAT { STATEMENTLIST } UNTIL ( CONDITION ) ${

}$
20 : STATEMENTNO -> DO { LABEL STATEMENTLIST } WHILE ( LABEL CONDITION ) ${
backpatch(stack[top-6].nextlist, stack[top-2].instr);
backpatch(stack[top-1].truelist, stack[top-7].instr);
stack[top-9].nextlist = stack[top-1].falselist;
# gen('goto', stack[top-7].instr);
top -= 9;
}$
21 : STATEMENTNO -> FOR ( EXPRESSIONLISTVAR ) { STATEMENTLIST } ${

}$
22 : STATEMENTNO -> FOR ( EXPRESSIONLISTVAR ) STATEMENT ${

}$
23 : STATEMENTNO -> RETURN EXPRESSION ${

}$
24 : STATEMENTNO -> BREAK ; ${

}$
25 : STATEMENTNO -> ; ${

}$
26 : STATEMENTNO -> # ${

}$
27 : ASSIGN -> INT ${

}$
28 : ASSIGN -> EXPRESSION ${

}$
29 : ASSIGN -> IDENTIFIER ( EXPRESSIONLIST ) ${

}$
30 : ASSIGN -> FUN ${

}$
31 : FUN -> FUNCTION ( EXPRESSIONLIST ) { STATEMENTLIST } ${

}$
32 : FUN -> FUNCTION ( EXPRESSIONLIST ) ${

}$
33 : IFSTMT -> IF ( CONDITION ) LABEL IFBLOCK GOTOLABEL LABEL ELIFSTMT ${
backpatch(stack[top-6].truelist, stack[top-4].instr);
backpatch(stack[top-6].falselist, stack[top-1].instr);
tmp = merge(stack[top-3].nextlist, stack[top-2].nextlist);
stack[top-8].nextlist = merge(tmp, stack[top].nextlist);
top -= 8;
}$
34 : ELIFSTMT -> ELSEIF ( CONDITION ) IFBLOCK ELIFSTMT ${

}$
35 : ELIFSTMT -> ELSE IFBLOCK ${
stack[top-1] = stack[top]; # ELSE has no info
top -= 1;
}$
36 : ELIFSTMT -> EPSILON ${

}$
37 : IFBLOCK -> STATEMENT ${

}$
38 : IFBLOCK -> { STATEMENTLIST } ${

}$
39 : EXPRESSIONLIST -> EXPRESSION ${

}$
40 : EXPRESSIONLIST -> EXPRESSIONLIST , EXPRESSION ${

}$
41 : EXPRESSIONLISTVAR -> EXPRESSION ${

}$
42 : EXPRESSIONLISTVAR -> EXPRESSIONLISTVAR ; EXPRESSION ${

}$
43 : EXPRESSION -> COMPUTEEXPR ${

}$
44 : EXPRESSION -> PARTEXPR ${

}$
45 : EXPRESSION -> CONDITION ${

}$
46 : PARTEXPR -> VARIABLE ${

}$
47 : PARTEXPR -> INT ${

}$
48 : PARTEXPR -> FLOAT ${

}$
49 : PARTEXPR -> IDENTIFIER ${

}$
50 : PARTEXPR -> PARTEXPR = PARTEXPR ${
stack[top-2].addr = gen('=', stack[top-2].addr, stack[top].addr);
top -= 2;
}$
51 : PARTEXPR -> ( EXPRESSION ) ${

}$
52 : PARTEXPR -> VARIABLE ( EXPRESSIONLIST ) ${

}$
53 : PARTEXPR -> COMPUTEEXPR ${

}$
54 : COMPUTEEXPR -> PARTEXPR + PARTEXPR ${
tmp = temp();
gen('+', stack[top-2].value, stack[top].value, tmp);
stack[top-2].value = tmp;
top -= 2;
}$
55 : COMPUTEEXPR -> PARTEXPR - PARTEXPR ${

}$
56 : COMPUTEEXPR -> PARTEXPR * PARTEXPR ${

}$
57 : COMPUTEEXPR -> PARTEXPR / PARTEXPR ${

}$
58 : COMPUTEEXPR -> PARTEXPR ++ ${

}$
59 : COMPUTEEXPR -> PARTEXPR -- ${

}$
60 : COMPAREEXPR -> PARTEXPR < PARTEXPR ${
stack[top-2].truelist = [nextinstr];
stack[top-2].falselist = [nextinstr+1];
gen('if', f"{stack[top-2].value} < {stack[top].value}", -1);
gen('goto', -1);
top -= 2;
}$
61 : COMPAREEXPR -> PARTEXPR > PARTEXPR ${

}$
62 : COMPAREEXPR -> PARTEXPR <= PARTEXPR ${

}$
63 : COMPAREEXPR -> PARTEXPR >= PARTEXPR ${

}$
64 : COMPAREEXPR -> PARTEXPR == PARTEXPR ${

}$
65 : COMPAREEXPR -> PARTEXPR != PARTEXPR ${
backpatch(stack[top-3].falselist, stack[top-1].instr);
stack[top-3].truelist = merge(stack[top-3].truelist, stack[top].truelist);
stack[top-3].falselist = stack[top].falselist;
top -= 3;
}$
66 : BOOLEXPR -> COMPAREEXPR && COMPAREEXPR ${

}$
67 : BOOLEXPR -> COMPAREEXPR || LABEL COMPAREEXPR ${

}$
68 : BOOLEXPR -> BOOLEXPR BOOLEXPR ${

}$
69 : CONDITION -> COMPAREEXPR ${

}$
70 : CONDITION -> BOOLEXPR ${

}$
71 : LABEL -> EPSILON ${
stack[top].instr = nextinstr;
}$
72 : GOTOLABEL -> EPSILON ${
stack[top].nextlist = [nextinstr];
gen('goto', -1);
}$