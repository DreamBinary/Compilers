0 : PROGRAM_ -> PROGRAM ${

}$
1 : PROGRAM -> STATEMENTLIST ${

}$
2 : INDEX -> INT ${
stack[top].value = int(stack[top].value);
}$
3 : INDEX -> VARIABLE ${

}$
4 : TYPE -> INTEGER ${
stack[top].type = 'integer';
stack[top].width = 4;
}$
5 : TYPE -> DOUBLE ${
stack[top].type = 'double';
stack[top].width = 8;
}$
6 : TYPE -> EPSILON ${
stack[top].type = None;
}$
7 : VARIABLE -> TYPE IDENTIFIER ${
if stack[top-1].type is not None:
    table[stack[top].value] = (stack[top-1].type, stack[top-1].width);
stack[top-1].value = stack[top].value;
# stack[top-1].type = stack[top-1].type;
# stack[top-1].width = stack[top-1].width;
top -= 1;
}$
8 : VARIABLE -> VARIABLE [ INDEX ] ${
if stack[top-3].type is None:
    if stack[top-3].value not in table:
        error(f"Variable {stack[top-3].value} not declared.");
    else:
        stack[top-3].type = table[stack[top-3].value][0];
        # stack[top-3].width = 4 if stack[top-3].type else 8;
    tmp = temp();
    # gen('*', stack[top-3].width, stack[top-1].value, tmp);
    gen('*', 4 if stack[top-3].type else 8, stack[top-1].value, tmp);
    tmp2 = temp();
    gen('', f"{stack[top-3].value}[{tmp}]", None, tmp2);
    stack[top-3].value = tmp2;
else:
    table[stack[top-3].value] = (f"{stack[top-3].type}[]", stack[top-1].value);
    stack[top-3].value = f"{stack[top-3].value}[{stack[top-1].value}]";
top -= 3;
}$
9 : VARIABLE -> VARIABLE [ INDEX ] [ INDEX ] ${
if store is not None:
    table[stack[top-6].value] = (f"{stack[top-6].type}[][]", stack[top-4].value, stack[top-1].value);
    stack[top-6].value = f"{stack[top-6].value}[{stack[top-3].value}][{stack[top-1].value}]";
elif stack[top-6].type is None: # use variable
    if stack[top-6].value not in table:
        error(f"Variable {stack[top-6].value} not declared.");
        stack[top-6].type = 'integer' # for continuing parsing
    else:
        stack[top-6].type = table[stack[top-6].value][0];
    tmp1 = temp();
    gen('*', 4 if stack[top-6].type else 8, stack[top-4].value, tmp1);
    tmp2 = temp();
    gen('*', 4 if stack[top-6].type else 8, stack[top-1].value, tmp2);
    tmp3 = temp();
    gen('+', tmp2, tmp1, tmp3);
    tmp4 = temp();
    gen('', f"{stack[top-6].value}[{tmp3}]", None, tmp4);
    stack[top-6].value = tmp4;
else: # declare variable
    table[stack[top-6].value] = (f"{stack[top-6].type}[][]", stack[top-4].value, stack[top-1].value);
    stack[top-6].value = f"{stack[top-6].value}[{stack[top-3].value}][{stack[top-1].value}]";
top -= 6;
}$
10 : VARIABLELIST -> VARIABLE ${

}$
11 : VARIABLELIST -> VARIABLE , VARIABLELIST ${
store = stack[top-2].type;
stack[top-2].type = stack[top].type;
top -= 2;
}$
12 : STATEMENTLIST -> STATEMENT LABEL STATEMENTLIST ${
backpatch(stack[top-2].nextlist, stack[top-1].instr);
stack[top-2].nextlist = merge(stack[top-2].nextlist, stack[top].nextlist);
stack[top-2].value = stack[top].value;
top -= 2;
}$
13 : STATEMENTLIST -> EPSILON ${

}$
14 : STATEMENT -> STATEMENTNO ${

}$
15 : STATEMENT -> STATEMENTNO ; ${
top -= 1;
}$
16 : STATEMENTNO -> VARIABLELIST ${

}$
17 : STATEMENTNO -> VARIABLE = ASSIGN ${
if stack[top-2].value not in table:
    error(f"Variable {stack[top-2].value} not declared."); # give error but continue parsing
backpatch(stack[top].nextlist, nextinstr);
gen('=', stack[top-2].value, stack[top].value);
top -= 2;
}$
18 : STATEMENTNO -> EXPRESSIONLIST ${

}$
19 : STATEMENTNO -> IFSTMT ${

}$
22 : STATEMENTNO -> FORSTMT ${

}$
20 : STATEMENTNO -> REPEAT { LABEL STATEMENTLIST } UNTIL ( LABEL CONDITION ) ${
backpatch(stack[top-6].nextlist, stack[top-2].instr);
backpatch(stack[top-1].falselist, stack[top-7].instr);
stack[top-9].nextlist = stack[top-1].truelist;

if breaklist:
    stack[top-9].nextlist.append(breaklist.pop());
# gen('goto', stack[top-7].instr);
top -= 9;
}$
21 : STATEMENTNO -> DO { LABEL STATEMENTLIST } WHILE ( LABEL CONDITION ) ${
backpatch(stack[top-6].nextlist, stack[top-2].instr);
backpatch(stack[top-1].truelist, stack[top-7].instr);
stack[top-9].nextlist = stack[top-1].falselist;

if breaklist:
    stack[top-9].nextlist.append(breaklist.pop());
# gen('goto', stack[top-7].instr);
top -= 9;
}$
24 : STATEMENTNO -> RETURN EXPRESSION ${
stack[top-1] = stack[top];
returnlist.append(nextinstr);
gen('goto', -1);
top -= 1;
}$
25 : STATEMENTNO -> BREAK ${
breaklist.append(nextinstr);
gen('goto', -1);
}$
26 : STATEMENTNO -> # ${

}$
27 : ASSIGN -> INT ${

}$
28 : ASSIGN -> EXPRESSION ${

}$
29 : ASSIGN -> FUN ${

}$
30 : FUN -> FUNCTION ( EXPRESSIONLIST ) { STATEMENTLIST } ${
stack[top-6].nextlist = merge(stack[top-1].nextlist, returnlist);
stack[top-6].value = 'FUNCTION';
top -= 6;
}$
31 : FUN -> FUNCTION ( EXPRESSIONLIST ) ${
stack[top-3].value = 'FUNCTION';
top -= 3;
}$
               -12 -11 -10      -9 -8    -7        -6 -5     -4           -3   -2  -1
31 : FORSTMT -> FOR ( EXPRESSION ; LABEL CONDITION ; LABEL EXPRESSION GOTOLABEL ) LABEL BLOCK ${
backpatch(stack[top-7].truelist, stack[top-1].instr);
backpatch(stack[top].nextlist, stack[top-5].instr);
backpatch(stack[top-3].nextlist, stack[top-8].instr);
stack[top-12].nextlist = stack[top-7].falselist;
gen('goto', stack[top-5].instr);
top -= 12;
}$
32 : IFSTMT -> IF ( CONDITION ) LABEL BLOCK GOTOLABEL LABEL ELIFSTMT ${
backpatch(stack[top-6].truelist, stack[top-4].instr);
backpatch(stack[top-6].falselist, stack[top-1].instr);
tmp = merge(stack[top-3].nextlist, stack[top-2].nextlist);
stack[top-8].nextlist = merge(tmp, stack[top].nextlist);
top -= 8;
}$
33 : ELIFSTMT -> ELSEIF ( CONDITION ) LABEL BLOCK GOTOLABEL LABEL ELIFSTMT ${
backpatch(stack[top-6].truelist, stack[top-4].instr);
backpatch(stack[top-6].falselist, stack[top-1].instr);
tmp = merge(stack[top-3].nextlist, stack[top-2].nextlist);
stack[top-8].nextlist = merge(tmp, stack[top].nextlist);
top -= 8;
}$
34 : ELIFSTMT -> ELSE BLOCK ${
stack[top-1] = stack[top]; # ELSE has no info
top -= 1;
}$
35 : ELIFSTMT -> EPSILON ${

}$
36 : BLOCK -> STATEMENT ${

}$
37 : BLOCK -> { STATEMENTLIST } ${
stack[top-2] = stack[top-1];
top -= 2;
}$
38 : EXPRESSIONLIST -> EXPRESSION ${
stack[top].value = stack[top].value if isinstance(stack[top].value, list) else [stack[top].value];
}$
39 : EXPRESSIONLIST -> EXPRESSION , EXPRESSIONLIST ${
tmp = stack[top-2].value if isinstance(stack[top-2].value, list) else [stack[top-2].value];
tmp += stack[top].value if isinstance(stack[top].value, list) else [stack[top].value];
stack[top-2].value = tmp;
top -= 2;
}$
42 : EXPRESSION -> COMPUTEEXPR ${

}$
43 : EXPRESSION -> PARTEXPR ${

}$
44 : EXPRESSION -> CONDITION ${

}$
45 : PARTEXPR -> VARIABLE ${

}$
46 : PARTEXPR -> INT ${

}$
47 : PARTEXPR -> FLOAT ${

}$
48 : PARTEXPR -> IDENTIFIER ${

}$
49 : PARTEXPR -> PARTEXPR = PARTEXPR ${
gen('=', stack[top-2].value, stack[top].value);
top -= 2;
}$
50 : PARTEXPR -> ( EXPRESSION ) ${
stack[top-2] = stack[top-1];
top -= 2;
}$
51 : PARTEXPR -> VARIABLE ( EXPRESSIONLIST ) ${
for i in stack[top-1].value:
    gen('param', i);
tmp = temp();
gen('', f"call {stack[top-3].value}, {len(stack[top-1].value)}", None, tmp);
stack[top-3].value = tmp;
stack[top-1].value = [];
top -= 3;
}$
52 : COMPUTEEXPR -> SUMEXPR ${

}$
53 : COMPUTEEXPR -> INCEXPR ${

}$
54 : SUMEXPR -> SUMEXPR + MULEXPR ${
tmp = temp();
gen('+', stack[top-2].value, stack[top].value, tmp);
stack[top-2].value = tmp;
top -= 2;
}$
55 : SUMEXPR -> SUMEXPR - MULEXPR ${
tmp = temp();
gen('-', stack[top-2].value, stack[top].value, tmp);
stack[top-2].value = tmp;
top -= 2;
}$
56 : SUMEXPR -> MULEXPR ${

}$
57 : MULEXPR -> MULEXPR * PARTEXPR ${
tmp = temp();
gen('*', stack[top-2].value, stack[top].value, tmp);
stack[top-2].value = tmp;
top -= 2;
}$
58 : MULEXPR -> MULEXPR / PARTEXPR ${
tmp = temp();
gen('/', stack[top-2].value, stack[top].value, tmp);
stack[top-2].value = tmp;
top -= 2;
}$
59 : MULEXPR -> PARTEXPR ${

}$
60 : INCEXPR -> PARTEXPR ${

}$
61 : INCEXPR -> PARTEXPR ++ ${
tmp = temp();
gen('+', stack[top-1].value, 1, tmp);
gen('=', stack[top-1].value, tmp);
top -= 1;
}$
62 : INCEXPR -> PARTEXPR -- ${
tmp = temp();
gen('-', stack[top-1].value, 1, tmp);
gen('=', stack[top-1].value, tmp);
top -= 1;
}$
63 : COMPAREEXPR -> PARTEXPR < PARTEXPR ${
stack[top-2].truelist = [nextinstr];
stack[top-2].falselist = [nextinstr+1];
gen('if', f"{stack[top-2].value} < {stack[top].value}", -1);
gen('goto', -1);
top -= 2;
}$
64 : COMPAREEXPR -> PARTEXPR > PARTEXPR ${
stack[top-2].truelist = [nextinstr];
stack[top-2].falselist = [nextinstr+1];
gen('if', f"{stack[top-2].value} > {stack[top].value}", -1);
gen('goto', -1);
top -= 2;
}$
65 : COMPAREEXPR -> PARTEXPR <= PARTEXPR ${
stack[top-2].truelist = [nextinstr];
stack[top-2].falselist = [nextinstr+1];
gen('if', f"{stack[top-2].value} <= {stack[top].value}", -1);
gen('goto', -1);
top -= 2;
}$
66 : COMPAREEXPR -> PARTEXPR >= PARTEXPR ${
stack[top-2].truelist = [nextinstr];
stack[top-2].falselist = [nextinstr+1];
gen('if', f"{stack[top-2].value} >= {stack[top].value}", -1);
gen('goto', -1);
top -= 2;
}$
67 : COMPAREEXPR -> PARTEXPR == PARTEXPR ${
stack[top-2].truelist = [nextinstr];
stack[top-2].falselist = [nextinstr+1];
gen('if', f"{stack[top-2].value} == {stack[top].value}", -1);
gen('goto', -1);
top -= 2;
}$
68 : COMPAREEXPR -> PARTEXPR != PARTEXPR ${
stack[top-2].truelist = [nextinstr];
stack[top-2].falselist = [nextinstr+1];
gen('if', f"{stack[top-2].value} != {stack[top].value}", -1);
gen('goto', -1);
top -= 2;
}$
69 : BOOLEXPR -> COMPAREEXPR && LABEL COMPAREEXPR ${
backpatch(stack[top-3].truelist, stack[top-1].instr);
stack[top-3].truelist = stack[top].truelist;
stack[top-3].falselist = merge(stack[top-3].falselist, stack[top].falselist);
top -= 3;
}$
70 : BOOLEXPR -> COMPAREEXPR || LABEL COMPAREEXPR ${
backpatch(stack[top-3].falselist, stack[top-1].instr);
stack[top-3].truelist = merge(stack[top-3].truelist, stack[top].truelist);
stack[top-3].falselist = stack[top].falselist;
top -= 3;
}$
71 : BOOLEXPR -> BOOLEXPR BOOLEXPR ${

}$
72 : CONDITION -> COMPAREEXPR ${

}$
73 : CONDITION -> BOOLEXPR ${

}$
74 : LABEL -> EPSILON ${
stack[top].instr = nextinstr;
}$
75 : GOTOLABEL -> EPSILON ${
stack[top].nextlist = [nextinstr];
gen('goto', -1);
}$
