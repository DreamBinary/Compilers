0 : PROGRAM_ -> PROGRAM ${

}$
1 : PROGRAM -> STATEMENTLIST ${

}$
2 : INDEX -> INT ${

}$
3 : INDEX -> VARIABLE ${

}$
4 : TYPE -> INTEGER ${
type = 'integer';
}$
5 : TYPE -> DOUBLE ${
type = 'double';
}$
6 : TYPE -> EPSILON ${
type = None;
}$
7 : VARIABLE -> TYPE IDENTIFIER ${
if type is not None:
    table[stack[top].value] = type;
stack[top-1].value = stack[top].value;
top -= 1;
}$
8 : VARIABLE -> VARIABLE [ INDEX ] ${
table[stack[top-3].value] = f"{type}[]";
stack[top-3].value = f"{stack[top-3].value}[{stack[top-1].value}]";
top -= 3;
}$
9 : VARIABLE -> VARIABLE [ INDEX ] [ INDEX ] ${

}$
10 : STATEMENTLIST -> STATEMENT ${

}$
11 : STATEMENTLIST -> STATEMENTLIST STATEMENT ${
stack[top-1].nextlist = merge(stack[top-1].nextlist, stack[top].nextlist);
stack[top-1].value = stack[top].value;
top -= 1;
}$
12 : STATEMENTLIST -> EPSILON ${

}$
13 : STATEMENT -> VARIABLE ${

}$
14 : STATEMENT -> VARIABLE = ASSIGN ${
if stack[top-2].value not in table:
    error(f"Variable {stack[top-2].value} not declared.");
else:
    gen('=', stack[top-2].value, stack[top].value);
top -= 2;
}$
15 : STATEMENT -> EXPRESSIONLIST ${

}$
16 : STATEMENT -> IFSTMT ${

}$
17 : STATEMENT -> REPEAT { STATEMENTLIST } UNTIL ( CONDITION ) ${

}$
18 : STATEMENT -> DO { LABEL STATEMENTLIST } WHILE ( LABEL CONDITION ) ${
backpatch(stack[top-6].nextlist, stack[top-2].instr);
backpatch(stack[top-1].truelist, stack[top-7].instr);
stack[top-9].nextlist = stack[top-1].falselist;
# gen('goto', stack[top-7].instr);
top -= 9;
}$
19 : STATEMENT -> FOR ( EXPRESSIONLISTVAR ) { STATEMENTLIST } ${

}$
20 : STATEMENT -> FOR ( EXPRESSIONLISTVAR ) STATEMENT ${

}$
21 : STATEMENT -> RETURN EXPRESSION ${

}$
22 : STATEMENT -> BREAK ; ${

}$
23 : STATEMENT -> ; ${

}$
24 : STATEMENT -> # ${

}$
25 : ASSIGN -> INT ${

}$
26 : ASSIGN -> EXPRESSION ${

}$
27 : ASSIGN -> IDENTIFIER ( EXPRESSIONLIST ) ${

}$
28 : ASSIGN -> FUN ${

}$
29 : FUN -> FUNCTION ( EXPRESSIONLIST ) { STATEMENTLIST } ${

}$
30 : FUN -> FUNCTION ( EXPRESSIONLIST ) ${

}$
31 : IFSTMT -> IF ( CONDITION ) LABEL IFBLOCK GOTOLABEL LABEL ELIFSTMT ${
backpatch(stack[top-6].truelist, stack[top-4].instr);
backpatch(stack[top-6].falselist, stack[top-1].instr);
tmp = merge(stack[top-3].nextlist, stack[top-2].nextlist);
stack[top-8].nextlist = merge(tmp, stack[top].nextlist);
top -= 8;
}$
32 : ELIFSTMT -> ELSEIF ( CONDITION ) IFBLOCK ELIFSTMT ${

}$
33 : ELIFSTMT -> ELSE IFBLOCK ${

}$
34 : ELIFSTMT -> EPSILON ${

}$
35 : IFBLOCK -> STATEMENTLIST ${

}$
36 : IFBLOCK -> { STATEMENTLIST } ${

}$
37 : EXPRESSIONLIST -> EXPRESSION ${

}$
38 : EXPRESSIONLIST -> EXPRESSIONLIST , EXPRESSION ${

}$
39 : EXPRESSIONLISTVAR -> EXPRESSION ${

}$
40 : EXPRESSIONLISTVAR -> EXPRESSIONLISTVAR ; EXPRESSION ${

}$
41 : EXPRESSION -> COMPUTEEXPR ${

}$
42 : EXPRESSION -> PARTEXPR ${

}$
43 : EXPRESSION -> CONDITION ${

}$
44 : PARTEXPR -> VARIABLE ${

}$
45 : PARTEXPR -> INT ${

}$
46 : PARTEXPR -> FLOAT ${

}$
47 : PARTEXPR -> IDENTIFIER ${

}$
48 : PARTEXPR -> PARTEXPR = PARTEXPR ${
stack[top-2].addr = gen('=', stack[top-2].addr, stack[top].addr);
top -= 2;
}$
49 : PARTEXPR -> ( EXPRESSION ) ${

}$
50 : PARTEXPR -> VARIABLE ( EXPRESSIONLIST ) ${

}$
51 : PARTEXPR -> COMPUTEEXPR ${

}$
52 : COMPUTEEXPR -> PARTEXPR + PARTEXPR ${
tmp = temp();
gen('+', stack[top-2].value, stack[top].value, tmp);
stack[top-2].value = tmp;
top -= 2;
}$
53 : COMPUTEEXPR -> PARTEXPR - PARTEXPR ${

}$
54 : COMPUTEEXPR -> PARTEXPR * PARTEXPR ${

}$
55 : COMPUTEEXPR -> PARTEXPR / PARTEXPR ${

}$
56 : COMPUTEEXPR -> PARTEXPR ++ ${

}$
57 : COMPUTEEXPR -> PARTEXPR -- ${

}$
58 : COMPAREEXPR -> PARTEXPR < PARTEXPR ${
stack[top-2].truelist = [nextinstr];
stack[top-2].falselist = [nextinstr+1];
gen('if', f"{stack[top-2].value} < {stack[top].value}", -1);
gen('goto', -1);
top -= 2;
}$
59 : COMPAREEXPR -> PARTEXPR > PARTEXPR ${

}$
60 : COMPAREEXPR -> PARTEXPR <= PARTEXPR ${

}$
61 : COMPAREEXPR -> PARTEXPR >= PARTEXPR ${

}$
62 : COMPAREEXPR -> PARTEXPR == PARTEXPR ${

}$
63 : COMPAREEXPR -> PARTEXPR != PARTEXPR ${

}$
64 : BOOLEXPR -> COMPAREEXPR && COMPAREEXPR ${

}$
65 : BOOLEXPR -> COMPAREEXPR || LABEL COMPAREEXPR ${
backpatch(stack[top-3].falselist, stack[top-1].instr);
stack[top-3].truelist = merge(stack[top-3].truelist, stack[top].truelist);
stack[top-3].falselist = stack[top].falselist;
top -= 3;
}$
66 : BOOLEXPR -> BOOLEXPR BOOLEXPR ${

}$
67 : CONDITION -> COMPAREEXPR ${

}$
68 : CONDITION -> BOOLEXPR ${

}$
69 : LABEL -> EPSILON ${
stack[top].instr = nextinstr;
}$
70 : GOTOLABEL -> EPSILON ${
# stack[top].nextlist = [nextinstr]; TODO
gen('goto ignore now', -1);
}$
