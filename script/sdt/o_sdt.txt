0: PROGRAM_ -> PROGRAM ${

}$
1: PROGRAM -> STATEMENTLIST ${

}$
2: INDEX -> INT ${

}$
3: INDEX -> VARIABLE ${

}$
4: TYPE -> INTEGER ${
type = 'int';
}$
5: TYPE -> DOUBLE ${
type = 'double';
}$
6: TYPE -> EPSILON ${
type = None;
}$
7: VARIABLE -> TYPE IDENTIFIER ${
table[stack[top].value] = type;
stack[top-1].value = stack[top].value;
top -= 1;
}$
8: VARIABLE -> VARIABLE [ INDEX ] ${
table[stack[top-3].value] = f"{type}[]";
stack[top-3].value = f"{stack[top-3].value}[{stack[top-1].value}]";
top -= 3;
}$
9: VARIABLE -> VARIABLE [ INDEX ] [ INDEX ] ${

top -= 6;
}$
10: STATEMENTLIST -> STATEMENT ${

}$
11: STATEMENTLIST -> STATEMENTLIST STATEMENT ${
stack[top-1].value = stack[top].value;
top -= 1;
}$
12: STATEMENTLIST -> EPSILON ${

}$
13: STATEMENT -> VARIABLE ${

}$
14: STATEMENT -> VARIABLE = ASSIGN ${
gen('=', stack[top-2].value, stack[top].value);
top -= 2;
}$
15: STATEMENT -> EXPRESSIONLIST ${

}$
16: STATEMENT -> IFSTMT ${

}$
17: STATEMENT -> REPEAT { STATEMENTLIST } UNTIL ( EXPRESSION ) ${


}$
18: STATEMENT -> DO { LABEL STATEMENTLIST } WHILE ( LABEL EXPRESSION ) ${
backpatch(stack[top-6].nextlist, stack[top-2].instr);
backpatch(stack[top-1].truelist, stack[top-7].instr);
stack[top-9].nextlist = stack[top-1].falselist;
# gen('goto', stack[top-7].instr);
top -= 9;
}$
19: STATEMENT -> FOR ( EXPRESSIONLISTVAR ) { STATEMENTLIST } ${

}$
20: STATEMENT -> FOR ( EXPRESSIONLISTVAR ) STATEMENT ${

}$
21: STATEMENT -> RETURN EXPRESSION ${

top -= 1;
}$
22: STATEMENT -> BREAK ; ${

top -= 2;
}$
23: STATEMENT -> ; ${

}$
24: STATEMENT -> # ${

}$
25: ASSIGN -> INT ${

}$
26: ASSIGN -> EXPRESSION ${

}$
27: ASSIGN -> IDENTIFIER ( EXPRESSIONLIST ) ${

top -= 3;
}$
28: ASSIGN -> FUN ${

}$
29: FUN -> FUNCTION ( EXPRESSIONLIST ) { STATEMENTLIST } ${

top -= 6;
}$
30: FUN -> FUNCTION ( EXPRESSIONLIST ) ${

top -= 3;
}$
31: IFSTMT -> IF ( EXPRESSION ) LABEL IFBLOCK LABEL ELIFSTMT ${
backpatch(stack[top-5].true, stack[top-3].addr);
backpatch(stack[top-5].false, stack[top-1].addr);
gen('goto', stack[top-7].addr);
gen('goto if', stack[top-5].true);
gen('goto', stack[top-1].addr);
top -= 7;
}$
32: ELIFSTMT -> ELSEIF ( EXPRESSION ) IFBLOCK ELIFSTMT ${

top -= 5;
}$
33: ELIFSTMT -> ELSE IFBLOCK ${
stack[top-1].addr = stack[top].addr;
top -= 1;
}$
34: ELIFSTMT -> EPSILON ${

}$
35: IFBLOCK -> STATEMENTLIST ${

}$
36: IFBLOCK -> { STATEMENTLIST } ${

top -= 2;
}$
37: EXPRESSIONLIST -> EXPRESSION ${

}$
38: EXPRESSIONLIST -> EXPRESSIONLIST , EXPRESSION ${
top -= 2;
}$
39: EXPRESSIONLISTVAR -> EXPRESSION ${

}$
40: EXPRESSIONLISTVAR -> EXPRESSIONLISTVAR ; EXPRESSION ${

top -= 2;
}$
41: EXPRESSION -> VARIABLE ${

}$
42: EXPRESSION -> INT ${

}$
43: EXPRESSION -> FLOAT ${

}$
44: EXPRESSION -> IDENTIFIER ${

}$
45: EXPRESSION -> EXPRESSION = EXPRESSION ${
stack[top-2].addr = gen('=', stack[top-2].addr, stack[top].addr);
top -= 2;
}$
46: EXPRESSION -> VARIABLE ( EXPRESSIONLIST ) ${

top -= 3;
}$
47: EXPRESSION -> EXPRESSION + EXPRESSION ${
tmp = temp();
gen('+', stack[top-2].value, stack[top].value, tmp);
stack[top-2].value = tmp;
top -= 2;
}$
48: EXPRESSION -> EXPRESSION - EXPRESSION ${

top -= 2;
}$
49: EXPRESSION -> EXPRESSION * EXPRESSION ${

top -= 2;
}$
50: EXPRESSION -> EXPRESSION / EXPRESSION ${

top -= 2;
}$
51: EXPRESSION -> EXPRESSION < EXPRESSION ${
stack[top-2].truelist.append(nextinstr);
stack[top-2].falselist.append(nextinstr+1);
gen('if', f"{stack[top-2].value} < {stack[top].value}", -1);
gen('goto', -1);
top -= 2;
}$
52: EXPRESSION -> EXPRESSION > EXPRESSION ${

top -= 2;
}$
53: EXPRESSION -> EXPRESSION >= EXPRESSION ${

top -= 2;
}$
54: EXPRESSION -> EXPRESSION <= EXPRESSION ${

}$
55: EXPRESSION -> EXPRESSION == EXPRESSION ${

}$
56: EXPRESSION -> EXPRESSION != EXPRESSION ${

}$
57: EXPRESSION -> EXPRESSION && EXPRESSION ${

}$
58: EXPRESSION -> EXPRESSION || LABEL EXPRESSION ${
backpatch(stack[top-3].falselist, stack[top-1].instr);
stack[top-3].truelist = merge(stack[top-3].truelist, stack[top].truelist);
stack[top-3].falselist = stack[top].falselist;
top -= 2;
}$
59: EXPRESSION -> EXPRESSION ++ ${

}$
60: EXPRESSION -> EXPRESSION -- ${

}$
61: EXPRESSION -> ( EXPRESSION ) ${

}$
62: LABEL -> EPSILON ${
stack[top].instr = nextinstr;
}$
